## 基于composite模式实现的Compoundshape类

composite模式主要有一下几类角色

- leaf 树叶
   表示内容的角色，该角色中不能放入其他对象，对应本实例程序中的triangle、square、rectangle、trapezium、round

- Composite 复合物
   表示容器的角色，可以放入小容器和内容，也就是leaf和composite，此实例中，由Compoundshape类代表composite

- component
   是leaf和composite角色具有一致性的角色，一般作为leaf和composite的父类，定义一些共有的行为和属性，此例中的Shape类代表

  ![1234352-205a607fddccdde8](C:\Users\16583\Desktop\1234352-205a607fddccdde8.webp)

## 重要接口说明：

添加/移除形状接口，这两个接口由Compoundshape类做有效实现。通过find_if函数来对m_vec进行迭代查找，该函数的第三个参数由lambda表达式充当，说明比较条件。

```
virtual void add(Shape* p)
	{
		// 使用find_if和lambda表达式来查找相同的Shape
		auto it = find_if(m_vec.begin(), m_vec.end(), [p](shared_ptr<Shape> ptr) {return p == ptr.get(); });
		if (it == m_vec.end())
			m_vec.push_back(shared_ptr<Shape>(p));
	}
	virtual void remove(Shape* p)
	{
		// 使用find_if和lambda表达式来查找相同的Shape
		auto it = find_if(m_vec.begin(), m_vec.end(), [p](shared_ptr<Shape> ptr) {return p == ptr.get(); });
		if (it == m_vec.end()) 
			return;
		m_vec.erase(it);
	}
```

